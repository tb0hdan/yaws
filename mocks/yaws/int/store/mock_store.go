// Code generated by mockery v2.46.3. DO NOT EDIT.

package store

import (
	models "yaws/internal/store/postgresql/models"

	mock "github.com/stretchr/testify/mock"

	uuid "github.com/google/uuid"
)

// MockStore is an autogenerated mock type for the Store type
type MockStore struct {
	mock.Mock
}

type MockStore_Expecter struct {
	mock *mock.Mock
}

func (_m *MockStore) EXPECT() *MockStore_Expecter {
	return &MockStore_Expecter{mock: &_m.Mock}
}

// AddCustomers provides a mock function with given fields: customers
func (_m *MockStore) AddCustomers(customers []models.Customer) ([]models.Customer, error) {
	ret := _m.Called(customers)

	if len(ret) == 0 {
		panic("no return value specified for AddCustomers")
	}

	var r0 []models.Customer
	var r1 error
	if rf, ok := ret.Get(0).(func([]models.Customer) ([]models.Customer, error)); ok {
		return rf(customers)
	}
	if rf, ok := ret.Get(0).(func([]models.Customer) []models.Customer); ok {
		r0 = rf(customers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Customer)
		}
	}

	if rf, ok := ret.Get(1).(func([]models.Customer) error); ok {
		r1 = rf(customers)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_AddCustomers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCustomers'
type MockStore_AddCustomers_Call struct {
	*mock.Call
}

// AddCustomers is a helper method to define mock.On call
//   - customers []models.Customer
func (_e *MockStore_Expecter) AddCustomers(customers interface{}) *MockStore_AddCustomers_Call {
	return &MockStore_AddCustomers_Call{Call: _e.mock.On("AddCustomers", customers)}
}

func (_c *MockStore_AddCustomers_Call) Run(run func(customers []models.Customer)) *MockStore_AddCustomers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]models.Customer))
	})
	return _c
}

func (_c *MockStore_AddCustomers_Call) Return(_a0 []models.Customer, _a1 error) *MockStore_AddCustomers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_AddCustomers_Call) RunAndReturn(run func([]models.Customer) ([]models.Customer, error)) *MockStore_AddCustomers_Call {
	_c.Call.Return(run)
	return _c
}

// AddProducts provides a mock function with given fields: products
func (_m *MockStore) AddProducts(products []models.Product) ([]models.Product, error) {
	ret := _m.Called(products)

	if len(ret) == 0 {
		panic("no return value specified for AddProducts")
	}

	var r0 []models.Product
	var r1 error
	if rf, ok := ret.Get(0).(func([]models.Product) ([]models.Product, error)); ok {
		return rf(products)
	}
	if rf, ok := ret.Get(0).(func([]models.Product) []models.Product); ok {
		r0 = rf(products)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Product)
		}
	}

	if rf, ok := ret.Get(1).(func([]models.Product) error); ok {
		r1 = rf(products)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_AddProducts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddProducts'
type MockStore_AddProducts_Call struct {
	*mock.Call
}

// AddProducts is a helper method to define mock.On call
//   - products []models.Product
func (_e *MockStore_Expecter) AddProducts(products interface{}) *MockStore_AddProducts_Call {
	return &MockStore_AddProducts_Call{Call: _e.mock.On("AddProducts", products)}
}

func (_c *MockStore_AddProducts_Call) Run(run func(products []models.Product)) *MockStore_AddProducts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].([]models.Product))
	})
	return _c
}

func (_c *MockStore_AddProducts_Call) Return(_a0 []models.Product, _a1 error) *MockStore_AddProducts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_AddProducts_Call) RunAndReturn(run func([]models.Product) ([]models.Product, error)) *MockStore_AddProducts_Call {
	_c.Call.Return(run)
	return _c
}

// Connect provides a mock function with given fields:
func (_m *MockStore) Connect() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Connect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_Connect_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Connect'
type MockStore_Connect_Call struct {
	*mock.Call
}

// Connect is a helper method to define mock.On call
func (_e *MockStore_Expecter) Connect() *MockStore_Connect_Call {
	return &MockStore_Connect_Call{Call: _e.mock.On("Connect")}
}

func (_c *MockStore_Connect_Call) Run(run func()) *MockStore_Connect_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockStore_Connect_Call) Return(_a0 error) *MockStore_Connect_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_Connect_Call) RunAndReturn(run func() error) *MockStore_Connect_Call {
	_c.Call.Return(run)
	return _c
}

// CreateOrder provides a mock function with given fields: order
func (_m *MockStore) CreateOrder(order models.Order) (models.Order, error) {
	ret := _m.Called(order)

	if len(ret) == 0 {
		panic("no return value specified for CreateOrder")
	}

	var r0 models.Order
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Order) (models.Order, error)); ok {
		return rf(order)
	}
	if rf, ok := ret.Get(0).(func(models.Order) models.Order); ok {
		r0 = rf(order)
	} else {
		r0 = ret.Get(0).(models.Order)
	}

	if rf, ok := ret.Get(1).(func(models.Order) error); ok {
		r1 = rf(order)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_CreateOrder_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateOrder'
type MockStore_CreateOrder_Call struct {
	*mock.Call
}

// CreateOrder is a helper method to define mock.On call
//   - order models.Order
func (_e *MockStore_Expecter) CreateOrder(order interface{}) *MockStore_CreateOrder_Call {
	return &MockStore_CreateOrder_Call{Call: _e.mock.On("CreateOrder", order)}
}

func (_c *MockStore_CreateOrder_Call) Run(run func(order models.Order)) *MockStore_CreateOrder_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Order))
	})
	return _c
}

func (_c *MockStore_CreateOrder_Call) Return(_a0 models.Order, _a1 error) *MockStore_CreateOrder_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_CreateOrder_Call) RunAndReturn(run func(models.Order) (models.Order, error)) *MockStore_CreateOrder_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCustomerById provides a mock function with given fields: id
func (_m *MockStore) DeleteCustomerById(id int32) (models.Customer, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCustomerById")
	}

	var r0 models.Customer
	var r1 error
	if rf, ok := ret.Get(0).(func(int32) (models.Customer, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(int32) models.Customer); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(models.Customer)
	}

	if rf, ok := ret.Get(1).(func(int32) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_DeleteCustomerById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCustomerById'
type MockStore_DeleteCustomerById_Call struct {
	*mock.Call
}

// DeleteCustomerById is a helper method to define mock.On call
//   - id int32
func (_e *MockStore_Expecter) DeleteCustomerById(id interface{}) *MockStore_DeleteCustomerById_Call {
	return &MockStore_DeleteCustomerById_Call{Call: _e.mock.On("DeleteCustomerById", id)}
}

func (_c *MockStore_DeleteCustomerById_Call) Run(run func(id int32)) *MockStore_DeleteCustomerById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int32))
	})
	return _c
}

func (_c *MockStore_DeleteCustomerById_Call) Return(_a0 models.Customer, _a1 error) *MockStore_DeleteCustomerById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_DeleteCustomerById_Call) RunAndReturn(run func(int32) (models.Customer, error)) *MockStore_DeleteCustomerById_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProductById provides a mock function with given fields: id
func (_m *MockStore) DeleteProductById(id uuid.UUID) (models.Product, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProductById")
	}

	var r0 models.Product
	var r1 error
	if rf, ok := ret.Get(0).(func(uuid.UUID) (models.Product, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(uuid.UUID) models.Product); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(models.Product)
	}

	if rf, ok := ret.Get(1).(func(uuid.UUID) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_DeleteProductById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProductById'
type MockStore_DeleteProductById_Call struct {
	*mock.Call
}

// DeleteProductById is a helper method to define mock.On call
//   - id uuid.UUID
func (_e *MockStore_Expecter) DeleteProductById(id interface{}) *MockStore_DeleteProductById_Call {
	return &MockStore_DeleteProductById_Call{Call: _e.mock.On("DeleteProductById", id)}
}

func (_c *MockStore_DeleteProductById_Call) Run(run func(id uuid.UUID)) *MockStore_DeleteProductById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_DeleteProductById_Call) Return(_a0 models.Product, _a1 error) *MockStore_DeleteProductById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_DeleteProductById_Call) RunAndReturn(run func(uuid.UUID) (models.Product, error)) *MockStore_DeleteProductById_Call {
	_c.Call.Return(run)
	return _c
}

// GetCustomerById provides a mock function with given fields: id
func (_m *MockStore) GetCustomerById(id int32) (models.Customer, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetCustomerById")
	}

	var r0 models.Customer
	var r1 error
	if rf, ok := ret.Get(0).(func(int32) (models.Customer, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(int32) models.Customer); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(models.Customer)
	}

	if rf, ok := ret.Get(1).(func(int32) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetCustomerById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCustomerById'
type MockStore_GetCustomerById_Call struct {
	*mock.Call
}

// GetCustomerById is a helper method to define mock.On call
//   - id int32
func (_e *MockStore_Expecter) GetCustomerById(id interface{}) *MockStore_GetCustomerById_Call {
	return &MockStore_GetCustomerById_Call{Call: _e.mock.On("GetCustomerById", id)}
}

func (_c *MockStore_GetCustomerById_Call) Run(run func(id int32)) *MockStore_GetCustomerById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int32))
	})
	return _c
}

func (_c *MockStore_GetCustomerById_Call) Return(_a0 models.Customer, _a1 error) *MockStore_GetCustomerById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetCustomerById_Call) RunAndReturn(run func(int32) (models.Customer, error)) *MockStore_GetCustomerById_Call {
	_c.Call.Return(run)
	return _c
}

// GetCustomers provides a mock function with given fields: limit, offset
func (_m *MockStore) GetCustomers(limit int32, offset int32) ([]models.Customer, error) {
	ret := _m.Called(limit, offset)

	if len(ret) == 0 {
		panic("no return value specified for GetCustomers")
	}

	var r0 []models.Customer
	var r1 error
	if rf, ok := ret.Get(0).(func(int32, int32) ([]models.Customer, error)); ok {
		return rf(limit, offset)
	}
	if rf, ok := ret.Get(0).(func(int32, int32) []models.Customer); ok {
		r0 = rf(limit, offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Customer)
		}
	}

	if rf, ok := ret.Get(1).(func(int32, int32) error); ok {
		r1 = rf(limit, offset)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetCustomers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCustomers'
type MockStore_GetCustomers_Call struct {
	*mock.Call
}

// GetCustomers is a helper method to define mock.On call
//   - limit int32
//   - offset int32
func (_e *MockStore_Expecter) GetCustomers(limit interface{}, offset interface{}) *MockStore_GetCustomers_Call {
	return &MockStore_GetCustomers_Call{Call: _e.mock.On("GetCustomers", limit, offset)}
}

func (_c *MockStore_GetCustomers_Call) Run(run func(limit int32, offset int32)) *MockStore_GetCustomers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int32), args[1].(int32))
	})
	return _c
}

func (_c *MockStore_GetCustomers_Call) Return(_a0 []models.Customer, _a1 error) *MockStore_GetCustomers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetCustomers_Call) RunAndReturn(run func(int32, int32) ([]models.Customer, error)) *MockStore_GetCustomers_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrderById provides a mock function with given fields: id
func (_m *MockStore) GetOrderById(id uuid.UUID) (models.Order, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetOrderById")
	}

	var r0 models.Order
	var r1 error
	if rf, ok := ret.Get(0).(func(uuid.UUID) (models.Order, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(uuid.UUID) models.Order); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(models.Order)
	}

	if rf, ok := ret.Get(1).(func(uuid.UUID) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetOrderById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrderById'
type MockStore_GetOrderById_Call struct {
	*mock.Call
}

// GetOrderById is a helper method to define mock.On call
//   - id uuid.UUID
func (_e *MockStore_Expecter) GetOrderById(id interface{}) *MockStore_GetOrderById_Call {
	return &MockStore_GetOrderById_Call{Call: _e.mock.On("GetOrderById", id)}
}

func (_c *MockStore_GetOrderById_Call) Run(run func(id uuid.UUID)) *MockStore_GetOrderById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_GetOrderById_Call) Return(_a0 models.Order, _a1 error) *MockStore_GetOrderById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetOrderById_Call) RunAndReturn(run func(uuid.UUID) (models.Order, error)) *MockStore_GetOrderById_Call {
	_c.Call.Return(run)
	return _c
}

// GetOrders provides a mock function with given fields: limit, offset, status, paymentStatus
func (_m *MockStore) GetOrders(limit int32, offset int32, status string, paymentStatus string) ([]models.Order, error) {
	ret := _m.Called(limit, offset, status, paymentStatus)

	if len(ret) == 0 {
		panic("no return value specified for GetOrders")
	}

	var r0 []models.Order
	var r1 error
	if rf, ok := ret.Get(0).(func(int32, int32, string, string) ([]models.Order, error)); ok {
		return rf(limit, offset, status, paymentStatus)
	}
	if rf, ok := ret.Get(0).(func(int32, int32, string, string) []models.Order); ok {
		r0 = rf(limit, offset, status, paymentStatus)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Order)
		}
	}

	if rf, ok := ret.Get(1).(func(int32, int32, string, string) error); ok {
		r1 = rf(limit, offset, status, paymentStatus)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetOrders_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetOrders'
type MockStore_GetOrders_Call struct {
	*mock.Call
}

// GetOrders is a helper method to define mock.On call
//   - limit int32
//   - offset int32
//   - status string
//   - paymentStatus string
func (_e *MockStore_Expecter) GetOrders(limit interface{}, offset interface{}, status interface{}, paymentStatus interface{}) *MockStore_GetOrders_Call {
	return &MockStore_GetOrders_Call{Call: _e.mock.On("GetOrders", limit, offset, status, paymentStatus)}
}

func (_c *MockStore_GetOrders_Call) Run(run func(limit int32, offset int32, status string, paymentStatus string)) *MockStore_GetOrders_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int32), args[1].(int32), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockStore_GetOrders_Call) Return(_a0 []models.Order, _a1 error) *MockStore_GetOrders_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetOrders_Call) RunAndReturn(run func(int32, int32, string, string) ([]models.Order, error)) *MockStore_GetOrders_Call {
	_c.Call.Return(run)
	return _c
}

// GetProductById provides a mock function with given fields: id
func (_m *MockStore) GetProductById(id uuid.UUID) (models.Product, error) {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for GetProductById")
	}

	var r0 models.Product
	var r1 error
	if rf, ok := ret.Get(0).(func(uuid.UUID) (models.Product, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(uuid.UUID) models.Product); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(models.Product)
	}

	if rf, ok := ret.Get(1).(func(uuid.UUID) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetProductById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProductById'
type MockStore_GetProductById_Call struct {
	*mock.Call
}

// GetProductById is a helper method to define mock.On call
//   - id uuid.UUID
func (_e *MockStore_Expecter) GetProductById(id interface{}) *MockStore_GetProductById_Call {
	return &MockStore_GetProductById_Call{Call: _e.mock.On("GetProductById", id)}
}

func (_c *MockStore_GetProductById_Call) Run(run func(id uuid.UUID)) *MockStore_GetProductById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_GetProductById_Call) Return(_a0 models.Product, _a1 error) *MockStore_GetProductById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetProductById_Call) RunAndReturn(run func(uuid.UUID) (models.Product, error)) *MockStore_GetProductById_Call {
	_c.Call.Return(run)
	return _c
}

// GetProducts provides a mock function with given fields: limit, offset, minQuantity
func (_m *MockStore) GetProducts(limit int32, offset int32, minQuantity int32) ([]models.Product, error) {
	ret := _m.Called(limit, offset, minQuantity)

	if len(ret) == 0 {
		panic("no return value specified for GetProducts")
	}

	var r0 []models.Product
	var r1 error
	if rf, ok := ret.Get(0).(func(int32, int32, int32) ([]models.Product, error)); ok {
		return rf(limit, offset, minQuantity)
	}
	if rf, ok := ret.Get(0).(func(int32, int32, int32) []models.Product); ok {
		r0 = rf(limit, offset, minQuantity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]models.Product)
		}
	}

	if rf, ok := ret.Get(1).(func(int32, int32, int32) error); ok {
		r1 = rf(limit, offset, minQuantity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_GetProducts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProducts'
type MockStore_GetProducts_Call struct {
	*mock.Call
}

// GetProducts is a helper method to define mock.On call
//   - limit int32
//   - offset int32
//   - minQuantity int32
func (_e *MockStore_Expecter) GetProducts(limit interface{}, offset interface{}, minQuantity interface{}) *MockStore_GetProducts_Call {
	return &MockStore_GetProducts_Call{Call: _e.mock.On("GetProducts", limit, offset, minQuantity)}
}

func (_c *MockStore_GetProducts_Call) Run(run func(limit int32, offset int32, minQuantity int32)) *MockStore_GetProducts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(int32), args[1].(int32), args[2].(int32))
	})
	return _c
}

func (_c *MockStore_GetProducts_Call) Return(_a0 []models.Product, _a1 error) *MockStore_GetProducts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_GetProducts_Call) RunAndReturn(run func(int32, int32, int32) ([]models.Product, error)) *MockStore_GetProducts_Call {
	_c.Call.Return(run)
	return _c
}

// PaymentWebhook provides a mock function with given fields: webhook
func (_m *MockStore) PaymentWebhook(webhook models.Webhook) error {
	ret := _m.Called(webhook)

	if len(ret) == 0 {
		panic("no return value specified for PaymentWebhook")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(models.Webhook) error); ok {
		r0 = rf(webhook)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockStore_PaymentWebhook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PaymentWebhook'
type MockStore_PaymentWebhook_Call struct {
	*mock.Call
}

// PaymentWebhook is a helper method to define mock.On call
//   - webhook models.Webhook
func (_e *MockStore_Expecter) PaymentWebhook(webhook interface{}) *MockStore_PaymentWebhook_Call {
	return &MockStore_PaymentWebhook_Call{Call: _e.mock.On("PaymentWebhook", webhook)}
}

func (_c *MockStore_PaymentWebhook_Call) Run(run func(webhook models.Webhook)) *MockStore_PaymentWebhook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Webhook))
	})
	return _c
}

func (_c *MockStore_PaymentWebhook_Call) Return(_a0 error) *MockStore_PaymentWebhook_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockStore_PaymentWebhook_Call) RunAndReturn(run func(models.Webhook) error) *MockStore_PaymentWebhook_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCustomerById provides a mock function with given fields: customer, id
func (_m *MockStore) UpdateCustomerById(customer models.Customer, id int32) (models.Customer, error) {
	ret := _m.Called(customer, id)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCustomerById")
	}

	var r0 models.Customer
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Customer, int32) (models.Customer, error)); ok {
		return rf(customer, id)
	}
	if rf, ok := ret.Get(0).(func(models.Customer, int32) models.Customer); ok {
		r0 = rf(customer, id)
	} else {
		r0 = ret.Get(0).(models.Customer)
	}

	if rf, ok := ret.Get(1).(func(models.Customer, int32) error); ok {
		r1 = rf(customer, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_UpdateCustomerById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCustomerById'
type MockStore_UpdateCustomerById_Call struct {
	*mock.Call
}

// UpdateCustomerById is a helper method to define mock.On call
//   - customer models.Customer
//   - id int32
func (_e *MockStore_Expecter) UpdateCustomerById(customer interface{}, id interface{}) *MockStore_UpdateCustomerById_Call {
	return &MockStore_UpdateCustomerById_Call{Call: _e.mock.On("UpdateCustomerById", customer, id)}
}

func (_c *MockStore_UpdateCustomerById_Call) Run(run func(customer models.Customer, id int32)) *MockStore_UpdateCustomerById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Customer), args[1].(int32))
	})
	return _c
}

func (_c *MockStore_UpdateCustomerById_Call) Return(_a0 models.Customer, _a1 error) *MockStore_UpdateCustomerById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_UpdateCustomerById_Call) RunAndReturn(run func(models.Customer, int32) (models.Customer, error)) *MockStore_UpdateCustomerById_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateOrderStatus provides a mock function with given fields: orderStatus
func (_m *MockStore) UpdateOrderStatus(orderStatus models.OrderStatus) (models.Order, error) {
	ret := _m.Called(orderStatus)

	if len(ret) == 0 {
		panic("no return value specified for UpdateOrderStatus")
	}

	var r0 models.Order
	var r1 error
	if rf, ok := ret.Get(0).(func(models.OrderStatus) (models.Order, error)); ok {
		return rf(orderStatus)
	}
	if rf, ok := ret.Get(0).(func(models.OrderStatus) models.Order); ok {
		r0 = rf(orderStatus)
	} else {
		r0 = ret.Get(0).(models.Order)
	}

	if rf, ok := ret.Get(1).(func(models.OrderStatus) error); ok {
		r1 = rf(orderStatus)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_UpdateOrderStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateOrderStatus'
type MockStore_UpdateOrderStatus_Call struct {
	*mock.Call
}

// UpdateOrderStatus is a helper method to define mock.On call
//   - orderStatus models.OrderStatus
func (_e *MockStore_Expecter) UpdateOrderStatus(orderStatus interface{}) *MockStore_UpdateOrderStatus_Call {
	return &MockStore_UpdateOrderStatus_Call{Call: _e.mock.On("UpdateOrderStatus", orderStatus)}
}

func (_c *MockStore_UpdateOrderStatus_Call) Run(run func(orderStatus models.OrderStatus)) *MockStore_UpdateOrderStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.OrderStatus))
	})
	return _c
}

func (_c *MockStore_UpdateOrderStatus_Call) Return(_a0 models.Order, _a1 error) *MockStore_UpdateOrderStatus_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_UpdateOrderStatus_Call) RunAndReturn(run func(models.OrderStatus) (models.Order, error)) *MockStore_UpdateOrderStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProductById provides a mock function with given fields: product, id
func (_m *MockStore) UpdateProductById(product models.Product, id uuid.UUID) (models.Product, error) {
	ret := _m.Called(product, id)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProductById")
	}

	var r0 models.Product
	var r1 error
	if rf, ok := ret.Get(0).(func(models.Product, uuid.UUID) (models.Product, error)); ok {
		return rf(product, id)
	}
	if rf, ok := ret.Get(0).(func(models.Product, uuid.UUID) models.Product); ok {
		r0 = rf(product, id)
	} else {
		r0 = ret.Get(0).(models.Product)
	}

	if rf, ok := ret.Get(1).(func(models.Product, uuid.UUID) error); ok {
		r1 = rf(product, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockStore_UpdateProductById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProductById'
type MockStore_UpdateProductById_Call struct {
	*mock.Call
}

// UpdateProductById is a helper method to define mock.On call
//   - product models.Product
//   - id uuid.UUID
func (_e *MockStore_Expecter) UpdateProductById(product interface{}, id interface{}) *MockStore_UpdateProductById_Call {
	return &MockStore_UpdateProductById_Call{Call: _e.mock.On("UpdateProductById", product, id)}
}

func (_c *MockStore_UpdateProductById_Call) Run(run func(product models.Product, id uuid.UUID)) *MockStore_UpdateProductById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(models.Product), args[1].(uuid.UUID))
	})
	return _c
}

func (_c *MockStore_UpdateProductById_Call) Return(_a0 models.Product, _a1 error) *MockStore_UpdateProductById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockStore_UpdateProductById_Call) RunAndReturn(run func(models.Product, uuid.UUID) (models.Product, error)) *MockStore_UpdateProductById_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockStore creates a new instance of MockStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockStore {
	mock := &MockStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
